/**
 * 服务端组件（类似于SSR）
 *  1、提供了直接访问服务端资源（如：数据库、文件系统、内部的微服务等）的可能，因此开发起来会更容易；
 *  2、避免了不必要的客户端和服务端之间的交互，因此性能更快；
 *  3、允许一些类库可以直接运行在服务端，因此减小了客户端包文件的大小。但同时可能给服务端内存使用造成很大影响
 *  4、服务端组件还给开发过程带来了更好的体验，特别是在代码切割上
 * 
 * 与SSR的不同：SSR在初始化加载后的数据更新请求会导致页面组件的二次渲染，从而影响性能和客户体验；使用服务端组件时，
 * 是将服务端组件整体合并到客户端ui树里面，不会对其他状态产生影响。React 通过整体 UI 模块更新的方式，达到保持客户端状态的目的，极大的增强了用户体验。
 *  缺点：服务端组件不能有任何交互行为（例如：不能使用 useState()，useEffect()）。
 * 但是你可以通过在服务端组件内部引入客户端组件（客户端组件是允许存在交互行为的）的方式来解决这个问题。
 */

 /**
  * CDN加速原理：
  *     全称内容分发网络（Content Delivery Network）
  *     通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，
  * 使用户可以就近取得所需的内容，提高用户访问网站的响应速度。
  *     可以解决网络宽带小、用户访问量大、网点分布不均等问题
  *     优点体现在：
  *     1、缓解甚至消除了不同运营商之间互联的瓶颈造成的影响
  *     2、减轻了各省的出口带宽压力
  *     3、缓解了骨干网的压力
  *     4、优化了网上热点内容的分布
  * 
  *     CDN是在原网站访问上添加了CDN层（智能调度DNS：根据一定的算法和策略（静态拓扑、容量等）将最合适的CDN节点ip地址返回给localDNS，同时也需要
  * 和分布在各地的CDN节点保持通信，跟踪各节点的健康状态容量等、CDN节点：本地保存服务器缓存以后后续使用；将获取数据传给客户端，完成数据服务。
  * 还可以负载均衡，内容cache服务器，共享存储）
  */
 /**
  * dom节点和渲染树节点
  *     渲染树节点（渲染器），是在文档解析和创建dom节点后创建的，会计算dom节点的样式信息
  *     渲染树节点是由dom节点通过调用attach方法创建的，是自上而下的递归操作。创建时父节点总是先于子节点，销毁时子节点总是先于父节点销毁
  * DOM 树与 HTML 标签一一对应，包括 head 和display: none隐藏元素
    * 渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性
  * css会阻塞dom解析嘛
    * 对于一个HTML文档来说，不管是内联还是外链的css，都会阻碍后续的dom渲染，但是不会阻碍后续dom的解析。
    * 当css文件放在中时，虽然css解析也会阻塞后续dom的渲染，但是在解析css的同时也在解析dom，所以等到css解析完毕就会逐步的渲染页面了。
  * 关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给用户能看到的界面这整个过程
  * 浏览器渲染过程：带有结束标签标识的Token不会创建节点对象
  * 1、解析HTML，构建DOM树（这里遇到外链，此时会发起请求）：字节数据--字符串--Token--Node--Dom
    2、解析CSS，生成CSS规则树
    3、合并DOM树和CSS规则，生成render树
    4、布局render树（Layout/reflow），负责各元素尺寸、位置的计算
        布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，
        位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，
        布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：
            float元素，absoulte元素，fixed元素会发生位置偏移。
            我们常说的脱离文档流，其实就是脱离Render Tree。
    5、绘制render树（paint），绘制页面像素信息
    6、浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上
  * 
  * 为什么js会阻塞dom创建：
  *     原因在于：JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建
  * 
  * 常见引起回流属性和方法：
  *     1、添加或者删除可见的DOM元素；
        2、元素尺寸改变——边距、填充、边框、宽度和高度
        3、内容变化，比如用户在input框中输入文字
        4、浏览器窗口尺寸改变——resize事件发生时
        5、计算 offsetWidth 和 offsetHeight 属性
        6、设置 style 属性的值
    引起重绘方法：
        中间带杠的css属性、还有color、background、outline、visibility等
  */
 // 以下几次回流重绘
 var s = document.body.style;
s.padding = "2px"; // 回流+重绘
s.border = "1px solid red"; // 再一次 回流+重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode('abc!'));
/**
 * 减少回流，重绘
 *  1、使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
    2、不要把节点的属性值放在一个循环里当成循环里的变量。
    3、不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
    4、动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
    5、CSS 选择符从右往左匹配查找，避免节点层级过多
    6、将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层
 */
/**
 * 为什么操作dom慢
 *   一般通过js去操作dom，会涉及到js和dom两个线程间的通信，势必会带来一些性能上的损耗，操作dom的次数变多，变复杂，就等同于一直处于线程间的通信，
 * 并且操作com可能会带来重绘重排的情况，导致性能上回有大损耗
 * 什么文件用强缓存、什么文件用协商缓存
 *      网站logo图片，名称等长时间不变的数据可以放强缓存；渲染页面的index。html文件用协商缓存，包装每次请求可能拿到最新的资源
 */
/**
 * 前端资源离线缓存
 *  PWA（渐进式web应用）：APP mainfest（添加到主屏幕） + service woker（离线缓存+消息推送）实现可安装可离线的网页应用
 *  优点:
 *  1、可添加到主屏幕，可全屏运行，与原生app无异
 *  2、可离线缓存
 *  3、实现了消息推送
 *  4、能在各种网络环境下使用，网差或断网下也可。给web应用提供了高级的可持续后台处理
 *  缺点：
 *  1、支持率不高，ios手机端，ie暂不支持
 *  2、chrome在移动端的占用率很低
 *  3、各大厂商还未明确支持PWA
 *  4、依赖的GCM服务国内网络无法使用
 *  5、微信小程序的竞争
 *  service worker：浏览器的一个高级特性，本质时一个web worker，是独立于网页运行的脚本。可以处理一些复杂的逻辑，处理完后通过postMessage通知主线程。
 * 拥有持久离线缓存的能力。
 *  特点:
 *  1、在页面注册安装成功后，运行于浏览器后台，不受页面刷新影响，可以监听和拦截作用域内所有页面的http请求
 *  2、网站需要使用https，本地开发可以使用localhost
 *  3、类似于web worker有单独的作用域范围、运行环境和执行线程
 *  4、不能操作dom，可以通过事件机制处理，事件驱动型服务线程
 * 离线缓存实现：
 *  a、注册过程中，浏览器会下载、解析并执行service worker
 *  b、成功执行后，install事件会被激活
 *  c、安装成功后，service worker可以控制在其范围内的一切资源了。
 *  d、event.waitUtil 用于在安装成功之前执行一些预装逻辑，但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率，安装成功后 ServiceWorker 状态会从 installing 变为 installed
 * 推送实现：
 *  a、提示用户并获取他们的订阅消息
 *  b、将信息保存在服务器上
 *  c、服务器发送消息给service worker
 *  d、service worker监听push事件，将通知详情推送给用户
 */
self.addEventListener('install', event => { 
    /* event.waitUtil 用于在安装成功之前执行一些预装逻辑
     但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率
     安装成功后 ServiceWorker 状态会从 installing 变为 installed */
      event.waitUntil(
        caches.open(cacheName)                  
        .then(cache => cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。        
          '/js/script.js',
          '/images/hello.png'
        ]))
      );
    });
      
    /**
    为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。
    如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。
    */
    self.addEventListener('fetch', function (event) {
        // ....
    });
    // 箭头函数和普通函数的区别
    /**
     * 1、箭头函数内部的this始终等于离它最近的外部函数的this，会捕获其所在的上下文的this值，普通函数的this可以通过bind、call、apply改变指向，
     * 可能指向window，或者调用函数的对象等
     * 2、箭头函数不能通过new关键字调用，没有原型，也不能作为构造函数
     * 3、箭头函数有隐性返回，function函数需要return返回
     * 4、箭头函数不支持arguments，需要在入参中通过展开符号去声明入参
     * 5、箭头函数不具有super。
     * 6、箭头函数不能当做Generator函数,不能使用yield关键字
     * 7、箭头函数不具有new.target
     */

