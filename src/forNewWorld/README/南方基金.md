经验浅：
    1. 在浏览器上输入一个url之后会发生什么，流程
    1、进行url解析（网络标准规定了URL只能是字母和数字，还有一些其它特殊符号；解析url是否规范，url编码规则是utf-8，中文用gb2312编码；encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码），构建网络请求：请求方法+url+http版本
    2、查找浏览器缓存：先查找强缓存，通过Cache-Control和Expires判断是否有效数据，有则取缓存中数据；没有则进入下一步协商缓存，协商缓存通过请求头中的缓存tag（Last-Modified 和 ETag）来确定是否需要重新请数据。
    3、需要发送http请求服务器获取最新的数据。此时会进行DNS解析来将域名和 IP 地址相互映射。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询（DNS解析流程：操作系统先查找浏览器缓存，缓存中维护一张域名与 IP 地址的对应表；未命中则继续查找本地hosts文件DNS缓存，再者本地域名服务器（到此是递归查询），还没查到则本地域名服务器向上级域名服务器进行查询（本地域名服务器向根域名服务器，顶级域名服务器，权限域名服务器，得到后自己缓存起来同时返回给操作系统，操作系统自动缓存起来，然后给浏览器，浏览器也会缓存起来），迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求（迭代查询常用）请求目标ip服务器获取数据）。浏览器缓存和操作系统缓存（hosts文件）。使用命令 ipconfig/displaydns 可以查看电脑中缓存的域名。
    DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但大多数情况下 DNS 都使用 UDP 进行传输。
    4、浏览器拿到ip地址后建立TCP连接（三次握手、四次挥手），发送http请求页面资源,获取的数据可能是html或者文本文档等
    5、拿到页面html/text资源后，开始解析html构建dom树（词法分析，语法分析；解析和标记化(有限自动状态机),建树算法创建对应的dom对象入树），解析css生成cssom树（格式化：css文本->结构化对象styleSheets；标准化：em->px、red->#ff0000、bold->700;样式继承和计算层叠），有js脚本执行时会暂停dom和css解析，先执行js脚本。
    关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给用户能看到的界面这整个过程
    6、合并DOM树和CSS规则，生成render树（render树中没有dom树中display：none、head头部等）
    7、布局Layout 树（Layout/reflow），负责各元素尺寸、位置的计算
    8、绘制render树（paint），“按顺序组合”-生成绘制列表，生成图块并栅格化（合成线程）绘制页面像素信息到显示器显示
 * 主要可实现GPU加速的属性：css3中的transform、opacity、filter
 * 开发过程中渲染优化：
 *  1、避免频繁使用内联样式style，可以使用class
 *  2、使用createDocumentFragment进行批量dom操作
 *  3、对于resize、scroll进行防抖节流处理
 *  4、合理使用GPU加速
 *  5、组件、标签使用唯一的key做键值迭代，不在render中处理数据，不然反复触发
 *  6、不必要的标签使用Fragment，可以减少内存占用 、web worker做密集型任务处理、优化webpack打包机制 、图片转base64
 页面渲染优化
    HTML文档结构层次尽量少，最好不深于六层；
    脚本尽量后放，放在前即可；
    少量首屏样式内联放在标签内；
    样式结构层次尽量简单；
    在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；
    减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；
    动画尽量使用在绝对定位或固定定位的元素上；
    隐藏在屏幕外，或在页面滚动时，尽量停止动画；
    尽量缓存DOM查找，查找器尽量简洁；
    涉及多域名的网站，可以开启域名预解析

    2.多线程了解吗，用过什么
    web worker是现代浏览器为js创造的多线程环境，可以新建并将部分任务分配到worker线程和js并行运行、两个线程可独立运行，互不干扰，可通过自带的消息机制相互通信
// 创建 worker
const worker = new Worker('work.js');

// 向 worker 线程推送消息
worker.postMessage('Hello World');

// 监听 worker 线程发送过来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
缺陷：
1、同源限制；2、无法使用document、window、alert等；3、无法加载本地缓存资源
    web worker可以用来处理cpu密集任务：Worker 线程在后台运行，可以在不中断主线程的情况下执行多个脚本和 JavaScript 任务 和js线程在隔离环境中执行、但可以使用进程间线程通信与js主线程交互，主线程可以专心处理dom渲染
<!--     3.介绍一下synchronized，跟可重入锁的区别，乐观锁悲观锁的应用场景 -->

    4.长列表怎么优化
    1、懒加载。第一次并不完全渲染所有的DOM节点，即可解决一部分场景下的问题，滑到时再多加载。缺点是难定位到某一位置数据，一直加载下去最终还是会有大量的DOM节点，导致滚动不流畅
    2、虚拟列表，列表局部渲染。比较知名的一些第三方库有vue-virtual-scroller、react-tiny-virtual-list、react-virtualized，react-virtualized这种大而全的库则是支持表格、集合、列表等多种情况下的局部加载方案。
    3、单纯列表虚拟渲染，通过可视区域窗口、虚拟数据列表、滚动占位区块、临界点判断模拟虚拟列表。

    5.数组和链表的区别，各适用什么场景
    * 数组：线性数据结构，连续内存空间，存储相同的数据类型，支持随机访问O1，插入，删除需要On的时间复杂度； 适合做底层数据结构
    * 链表：链式数据结构，非连续内存，内存可拓展，存储相同数据类型，插入删除高效，直接改变next即可，查询 需要依赖算法查询；通常会通过链表创建红黑树，平衡树、基数树等
    链表VS数组：
    1、读取与设置事件复杂度数组是O1，链表是On；但是在插入、删除的时候数组需要On，链表是O1.二分查找只能适用于数组。用链表或数组去实现栈复杂度性能一致，但如果是实现队列，那么链表的进出都会以O(1)的复杂度吊打数组
    2、遍历和排序：遍历和反转都是On复杂度，排序的话二者都是Onlogn
    3、内存消耗对比：数组需要使用整块的内存，可以被cpu预读取；链表占用内存更高，因为还有每个节点的指针消耗，内存不需要整块使用
    4、便利性：链表JavaScript还没有官方的数据结构提供，很多操作需要自己实现，无疑是麻烦很多；而数组官方的API一大箩筐，使用方便，如果数据量不大，完全使用数组也是没任何影响
    * 指针：相当于一个变量，存放其他变量在内存中的地址
    * 集合：典型如set、map、list等，特点是内存空间不连续，可扩容；数据类型未声明时为Object

    6.TCP三次握手，四次挥手（C表示客户端，S表示服务器）
三次握手：
    1、C发送SYN=1表示请求建立连接，并发送一个随机数x作为序列号seq=x给S，并进入SYN_SENT阶段，等待S确认
    2、服务器收到后，发送确认包ack=x+1，ACK=1表示确认号有效、然后也发一个SYN=1请求和C建立连接，也发一个seq=y的序列号，此时S进入SYN_RECV状态
    3、C收到S的包后，向服务器发送确认号ack=y+1，ACK=1，seq=x+1。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
四次挥手：
    1、C发送释放报文并停止发送数据。报文首部FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
    2、S收到后发出确认报文ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态.C收到S的确认后，进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
    3、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
    4、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。服务器在收到后就进入CLOSED状态了，撤销TCB后，就结束了这次的TCP连接。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
    常见问题：
    1、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
    假象网络不可靠，有可能最后一个ACK丢失。TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。 Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。 在CLOSE_WAIT，FIN_WAIT_2期间服务器任然可以传输数据给客户端
    2、为什么建立连接是三次，二次行不行，为什么挥手又是四次。
    两次的话服务器无法知道客户端的接受能力是否正常。
    三次握手可以让双方都知道对方发送、接受能力正常。也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。不然客户端可能不知晓连接是否建立成功，就会忽略服务器发来的数据分组。而服务器在发送没有确认后超时，反复重传数据，造成死锁。
    关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN关闭报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手
    3、如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去， 白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

    7.七层协议，四层协议
    1、开放式系统互联模型（Open System Interconnection Model，简称为 OSI 模型）七层:从上到下应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
    2、TCP/IP体系结构四层：应用层（如TELNET、FTP、SMTP协议等）、传输层（TCP，UDP）、网络层（IP）、网络接口层（对于七层中的底下两层）
    5、五层：从上到下应用层、传输层、网络层、数据链路层、物理层
    对应的单位：物理层（比特），数据链路层（帧），网络层（报文）

    8.http协议，有哪些方法
    GET、POST、PUT、DELETE、HEAD、OPTIONS
    GET和POST的区别：
    * 1、缓存角度，get请求会被浏览器主动缓存下来，留下历史记录，post不会
    * 2、编码角度，get只接受ASCII字符，只能进行url编码，post没有限制
    * 3、参数角度，get参数会体现在url中，post放在请求体中
    * 4、幂等性，get是幂等的，post不是（幂等性是指执行相同的操作，结果也是相同的）
    * 5、tcp角度，get请求会把请求报文一次性发送出去，post请求会分两次（火狐浏览器除外），首先发送header部分，响应100后继续发送body部分

    PUT方法是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档；如果那个文档存在的话，就用这个主体来代替它。
    HEAD方法与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查
    OPTIONS方法用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。

（结合项目聊）
经验深：
1项目架构图；
--build
------theme.js
------webpack.config.dev(product).js
------dll.config.js(一些库引用)
------global-css.js
--public
------index.html
------static(打包后的静态文件夹)
------favicon.ico(图标)
--src
------common
------config
------modules
----------common
--------------components
--------------LoginPages
--------------pageConfig
--------------resource
----------menuPage1(对应得一个模块下各菜单页面)
--------------api
--------------lib
------------------dict.js
------------------socket.js
------------------minxin.js
--------------components
------------------commonHead.js
--------------config
------------------reduxReducer.js
------------------route.js
--------------pages
------------------page1
----------------------index.js
--------------styles
------------------index.module.less
----------menuPage2(对应得一个模块下各菜单页面)
------util
----------requst.js
----------call.js
----------dayjs.js(等公共常用函数集合)
------redux
------setupProxy.js(前端开发的一个拦截代理)
--package.json
--.gitignore
--.eslintrc.js
--.babelrc
--README.md

2jvm调优;
3三次握手;
4Java锁,cas aqs，公平锁，非公平锁
5红黑树,b树
6hashmap实现

http特性：
    http1.1规范中有Pipelining试图解决在一个支持长久连接的客户端一次发送多个http请求，然后服务器按顺序回复多个http请求，这里不是说把多个请求组合成一个请求发出。浏览器默认不开启该功能。因为如果存在连接头阻塞，那其他顺序后面的请求就需要等待大量时间。http2中增加了多路复用的特性，多个http请求可以同时在同一个tcp连接中并行完成。如果页面存在很多数量图片标签，会在SSL握手后和服务器商量能不能用http2、能就使用http2的多路复用，不支持那就只有采用建立多个tcp连接去获取，chrome一般最大6个tcp连接。
滑动窗口：
    滑动窗口主要就是做限流和缓冲用的，每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为。已经处理好之前连续发的几个数据包了，然后就会重新更新自己的win的大小，要注意的是当tcp一端的win接近或者等于0的时候，传输将会停止，直到window update更新说buffer已经清空了，传输才会继续。
TCP常见攻击：（泛洪攻击）
    DDOS攻击：短时间内向服务器发送大量请求，耗尽服务器资源，让服务器无法正常服务。
    防范：
        1、针对有特征的请求进行请求拦截，设置硬件防火墙；或者操作系统使用iptables拦截攻击者ip地址；web服务器nginx设置deny 1.2.3.4过滤拦截请求
        2、在短时间内急剧扩容，提供几倍或几十倍的带宽，顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDOS 攻击。个人可以增加服务器镜像，将请求负载到对应的服务器上，以顶住大流量请求。
        3、CDN将网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。前提是网站大部分内容可以静态缓存的
        4、内核参数优化：限制SYN并发数量、超时时间，减少SYN-ACK数据包重发次数，使用SYN Cookie技术，增加backlog队列（默认1024）