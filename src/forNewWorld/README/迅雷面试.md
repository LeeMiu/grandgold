1、组件间通信eventBus存在的问题
    1、不同组件之间通信越来越多，代码逻辑性会下降，可阅读性变低
    2、对于每个actions父组件都需要一个on或者dispatch来处理
    3、事件多起来，很难查找事件从哪触发，业务性质强，可预测性差
2、src、href的区别
    href和src是有区别的，而且是不能相互替换的。我们在可替换的元素上使用src，然而把href用于在涉及的文档和外部资源之间建立一个关系。
    href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。
    <link href="style.css" rel="stylesheet" />
    浏览器明白当前资源是一个样式表，页面解析不会暂停（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在<style>标签里不相同，因此建议使用link标签而不是@import来吧样式表导入到html文档里。
    src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置
    <script src="script.js"></script>
    在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。这个过程与把js文件放到<script>标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。
3、script中的defer和async区别
    相同点：a、在加载脚本时是异步加载，不会阻塞页面 b、对于inline的script内联脚本无效 c、使用该属性的脚本中不能调用document.write方法 d、有脚本的onload的事件回调
    不同点：a、defer是html4.0定义的，async是html5.0中定义的 b、兼容下defer在ie4以上都可以用，async需要ie10以上的支持 c、async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。这也就决定了async比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。
4、flex布局
    采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。
    父容器的属性：
        flex-direction :  row | row-reverse | column | column-reverse;  该属性定义了 子元素排列方向
        justify-content: flex-start | flex-end | center | space-between | space-around;  该属性定义了子元素在主轴上的对齐方式。
        align-items:  flex-start | flex-end | center | baseline | stretch;  定义项目在交叉轴上如何对齐。
        **flex-wrap：**nowrap | wrap | wrap-reverse;  该属性称"轴线"：nowrap（默认）：不换行、wrap：换行，第一行在上方、wrap-reverse：换行，第一行在下方。
        **align-content: ** flex-start | flex-end | center | space-between | space-around | stretch; 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
5、http和https的理解，两者区别
    HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
    http存在安全风险：1、由于 HTTP 本身是明文传输，用户和服务端之间的传输内容都能被中间者查看 2、页面劫持，也就是直接篡改用户的浏览页面
    https其实就是安全版的http，它在http上加了一层SSL安全套接层。TLS是标准化的SSL，即TLS1.0 = SSL3.1
    TLS握手:（即建立连接的过程中通过证书、对称加密和非对称加密保证双方身份安全）
    加密套件列表：如TLS_ECDHE_WITH_AES_128_GCM_SHA256：意思是TLS握手过程中，使用ECDHE算法生成pre_random(这个数后面会介绍)，128位的AES算法进行对称加密，
    在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用SHA256算法。
    https的缺点：1、网络时耗，加密解密计算时耗 2、成本高：服务器成本，证书成本
    区别：1、https协议需要申请证书，一般免费证书较少，因而需要一定费用 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
6、http2
    相比于http/1.1，增加了新特性：1、多路复用，单一长连接，二进制格式传输，请求优先级设置 2、头部header压缩 3、服务端推送Server Push
    1、多路复用。HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，这些请求或回应在逻辑上分成了很多流（stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。而且不用按照顺序一一对应（但是同一个请求或响应的帧必须是有序的，不同的可以无序），这样就避免了"队头堵塞"，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题。http2还可以对stream指定优先级，优先级越高的越先响应。比如可以把js和css的优先级设置的高一些，让他们优先下载并执行。
    2、头部压缩。HTTP/2对头部信息采用HPACK压缩算法来减少报文头的大小。具体做法是把报文头信息中常见的名和值对应一个索引，维护了一张静态字典。但是对于一些动态的资源，比如，user-agent，需要维护一份可动态添加内容的共同动态字典，这份动态字典在数据传输的过程中逐步建立。index从62开始。然后将映射之后的数据用huffman编码。
    3、服务端推送。允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。服务端推送需要开发人员手动配置。
    nginx设置http2配置
        server {
            listen 443 ssl http2;
        }
7、手写节流throttle函数
    function myThrottle(fn, wait, immediate) {
        let time = null;
        let callNow = immediate;
        return function () {
            let context = this, args = arguments;
            if (callNow) {
                fn.apply(context, args);
                callNow = false;
            }
            if (!time) {
                time = setTimeout(() => {
                    fn.apply(context, args);
                    time = null;
                }, wait);
            }
        }
    }
8、call和bind的区别
    call是修改this后立即执行函数
    bind是利用柯理化思想，预先把 “需要处理的函数/改变的this/传递的参数” 等信息存储在闭包中，不会立即调用，而是返回一个绑定后的新函数
9、ajax和fetch区别
    Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，俗称的局部刷新。Ajax 的核心就是应用了 XMLHttpRequest 对象，通过这个对象，就可以实现在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。
    Fetch 是对原生的 XMLHttpRequest 对象一个替代的方案，它更加底层。符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里；提供的API丰富，脱离了XHR，是ES规范里新的实现方式。它同样是用 Promise 进行的封装，但是与 Axios 不同的是仅当网络故障时或请求被阻止时，才会标记为 reject；其他如500状态错误码时会时resolve状态。 Fetch 在第一次 then 返回的是一个 HTTP 响应，而不是真的 JSON。为了获取 JSON 的内容，我们需要使用 json() 方法。fetch 不会发送 cookies。除非你使用了 credentials 的初始化选项；fetch() 可以接受跨域 cookies；也可以使用 fetch() 建立起跨域会话。

    附加：区别介绍，ajax、juery ajax、axios、fetch
    ajax：全称Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。
    juery ajax：是 jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。
    axios：axios不是原生JS的，需要进行安装，它不但可以在客户端使用，也可以在nodejs端使用。Axios也可以在请求和响应阶段进行拦截。同样也是基于Promise对象的。特性：从浏览器中创建 XMLHttpRequests、从 node.js 创建 http 请求、支持 Promise API、拦截请求和响应等。
    fetch：Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义。使之今后可以被使用到更多地应用场景中：无论是service workers、Cache API、又或者是其他处理请求和响应的方式，甚至是任何一种需要你自己在程序中生成响应的方式。Fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的Promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。
10、vue中watch和computed区别
    Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。
11、typeof和instanceof区别，instanceof会存在什么问题
    typeof正确检测检测原始数据类型和普通object和函数。
    instanceof用来比较一个对象是否为某一个构造函数的实例，不适合检测一个对象本身的类型：({}) instanceof Object // true ([]) instanceof Object // true(准确应该是Array)因为原型链继承的关系，instanceof 会把数组都识别为 Object 对象。
12、父级元素出现塌陷的场景和解决方法。如果父级下只有一个子元素，设置margin-top：10px会有什么影响。为什么，怎么解决
    父元素不设置高度的时候靠子元素撑大，也就是说子元素有多高，父元素就有多高，当子元素浮动后，父元素就会高度塌陷。父元素高度塌陷后，父元素下面的元素就会向上移动，这样会导致整个页面的布局混乱。
    解决塌陷：
        1、给父元素设置固定的高度，固定高度后，父元素的高度就无法自适应子元素的高度了。 弊端：但是不能让元素高度自适应了 。   X
        2、给父元素设置overflow：hidden，解决高度塌陷并能实现高度自适应的方法（遵循BFC的显示原则） 弊端：只要里面的内容或者元素超出父元素以外，就会被隐藏；   X
        3、在浮动元素的下方添加一个空元素，并且给他设置一下属性。 弊端：会添加很多空标记，增加结构负担，产生代码冗余；    X
        4、display:table; 给父元素添加display：table；让父元素转换元素类型跟表格的特性一样； 弊端：会改变当前元素的元素类型；   X
        5、通过after伪类元素添加一个空白的块元素，css加下列属性，并给要清除的div加上clear_fix的类名。 推荐使用的方式，没有什么副作用。   √
        万精油
        .clear_fix:after {
            content: ""; /* 添加内容 */
            clear: both; /* 清楚两侧浮动 */
            display: block; /* 转换元素类型为块元素 */
            height: 0;
            overflow: hidden; /* 溢出隐藏属性 */
            visibility: hidden;/* 隐藏属性 */
        }
    如果父级下只有一个子元素，设置margin-top：10px会有什么影响
        实际效果会是父级元素和上一个元素产生间距。原因是BFC中规定相邻的两个或多个盒元素margin会合并成一个并共享之。单独嵌套也属于相邻，所以在样式表中优先级更高子元素的margin会覆盖外层父元素定义的margin。
        解决：
        1、为父元素添加：overflow：hidden；√
        2、为父元素或者子元素声明浮动（float：left；position：absolute）,可能会改变位置；
        3、为父元素添加border （border：1px solid transparent）边界 √
        4、为父元素或者子元素声明绝对定位（BFC）父元素display: flex，子元素display：inline-block; √
        5、修改父元素的高度，增加padding-top样式模拟padding-top：1px；
