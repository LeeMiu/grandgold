/**
 * TCP三次握手：
 * 概念SYN、seq、ACK分别是什么（都存在TCP首部中）
 * SYN：synchronous，标识建立联机，置为1。在握手完成后会被置为0，不然在传输过程中不断以为要建立连接
 * seq：sequence number 顺序号码，tcp握手中第一个字节的编号随机生成的
 * ack：acknowledge number 确认号码，标识已确认收到seq，其值为seq值+1
 * ACK：仅当ACK=1时，确认号ack才有效
 * RST：对方要求重新建立连接，复位
 * FIN：标识释放连接，FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
 * ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。
 * SYN_SEND表示同步已发送；SYN_RCVD表示同步已收到；ESTAB_LISHED表示已建立连接
 * FIN_WAIT_1终止等待1，CLOSE_WAIT：关闭等待；FIN_WAIT_2终止等待2；LAST_ACK服务器最后确认；TIME_WAIT：2*MSL（最长报文寿命）时间等待
 * 关闭时第一次seq为前面传输数据最后一个字节的序号+1。
 * 服务器是在LAST_ACK收到后就关闭了，客户端是在经过2*MSL时间等待后才进入CLOSED状态
 * 等待2*msl的原因：假象网络不可靠，有可能最后一个ACK丢失。TIME_WAIT状态就是用来重发可能丢失的ACK报文。
    * 在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。
    * 所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。
    * Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL
 * 在CLOSE_WAIT，FIN_WAIT_2期间服务器任然可以传输数据给客户端
 * 
 * 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    * TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，
    * 白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，
    * 时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，
    * 以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
 */